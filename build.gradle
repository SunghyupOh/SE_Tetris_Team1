plugins {
    id 'application'
    id 'jacoco'
    id 'checkstyle'
    id 'com.github.spotbugs' version '6.0.7'
}

// Version checking example using Gradle's version comparison
def minimumGradleVersion = "8.0"
def currentGradleVersion = gradle.gradleVersion

// Simple version comparison without importing VersionNumber
if (currentGradleVersion.split('\\.')[0].toInteger() < minimumGradleVersion.split('\\.')[0].toInteger()) {
    throw new GradleException("This project requires Gradle ${minimumGradleVersion} or higher. Current version: ${currentGradleVersion}")
}

println "✓ Gradle version check passed: ${currentGradleVersion}"

compileJava {
    options.encoding = 'UTF-8'
}

compileTestJava {
    options.encoding = 'UTF-8'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17) // 빌드 JDK 고정
    }
}

repositories {
    mavenCentral()
}

application {
    // 메인 클래스 FQCN
    mainClass = 'tetris.Tetris'
}

dependencies {
    
    implementation "javazoom:jlayer:1.0.1"
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    
    // 테스트 리포팅을 위한 의존성
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.2'
}

test {
    useJUnitPlatform()
    
    // 테스트 병렬 실행 비활성화 - 무한 루프 방지를 위해 순차 실행
    maxParallelForks = 1
    forkEvery = 1
    
    // GUI 테스트를 위해 헤드리스 모드 비활성화
    // systemProperty 'java.awt.headless', 'true'  // 주석 처리
    systemProperty 'junit.jupiter.execution.parallel.enabled', 'false'
    
    // 각 테스트 클래스별 타임아웃 강화
    systemProperty 'junit.jupiter.execution.timeout.default', '30s'
    systemProperty 'junit.jupiter.execution.timeout.testable.method.default', '30s'
    
    // 테스트 리포트 생성 설정
    reports {
        junitXml.required = true
        html.required = true
    }
    
    // 테스트 결과를 XML 형태로 출력 (GitHub Actions 호환)
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = true  // System.out.println 출력 활성화
        
        // 테스트 완료 후 요약 정보 출력
        afterSuite { desc, result ->
            if (!desc.parent) { // 루트 테스트 스위트인 경우
                println ""
                println "=" * 50
                println "🧪 JUnit 테스트 실행 결과"
                println "=" * 50
                println "총 테스트: ${result.testCount}"
                println "성공: ${result.successfulTestCount}"
                println "실패: ${result.failedTestCount}"
                println "건너뜀: ${result.skippedTestCount}"
                println "실행 시간: ${result.endTime - result.startTime}ms"
                
                if (result.failedTestCount > 0) {
                    println "❌ 일부 테스트가 실패했습니다."
                } else {
                    println "✅ 모든 테스트가 성공했습니다!"
                }
                println "=" * 50
                println ""
            }
        }
    }
    
    // 테스트 타임아웃 설정 - 강화
    timeout = Duration.ofMinutes(3)  // 전체 테스트 타임아웃을 3분으로 단축
    
    // JVM 옵션 추가 - 무한 루프 방지 강화
    jvmArgs '-XX:+UseG1GC', '-Xmx512m', '-XX:+HeapDumpOnOutOfMemoryError',
            '-XX:+ExitOnOutOfMemoryError', '-XX:MaxDirectMemorySize=128m'
    
    // 개별 테스트 클래스별 강제 종료 타임아웃
    systemProperty 'junit.jupiter.execution.timeout.mode', 'enabled'
    
    // 테스트 실패 시에도 계속 진행 (커버리지 리포트 생성을 위해)
    ignoreFailures = true
    
    // 문제있는 테스트 제외 (필요시)
    exclude '**/*LongRunning*'
}

// 테스트 커버리지 설정
jacoco {
    toolVersion = "0.8.8"
}

jacocoTestReport {
    dependsOn test
    
    reports {
        xml.required = true
        html.required = true
        csv.required = true  // CSV 리포트도 활성화하여 콘솔 출력용으로 사용
    }
    
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                // 메인 클래스나 UI 클래스 제외 (선택사항)
                '**/Tetris.class',
                '**/Main.class'
            ])
        }))
    }
    
    // 커버리지 리포트 생성 후 콘솔에 요약 정보 출력
    doLast {
        def csvFile = reports.csv.outputLocation.asFile.get()
        if (csvFile.exists()) {
            def coverageData = parseCoverageData(csvFile)
            printCoverageSummary(coverageData)
        }
        
        println ""
        println "📊 테스트 커버리지 리포트가 생성되었습니다:"
        println "   HTML: ${reports.html.outputLocation.asFile.get().toURI()}"
        println "   XML:  ${reports.xml.outputLocation.asFile.get()}"
        println ""
    }
}

// 테스트 실행 후 자동으로 커버리지 리포트 생성
test.finalizedBy jacocoTestReport

// 커버리지 데이터 파싱 함수
def parseCoverageData(csvFile) {
    def lines = csvFile.readLines()
    if (lines.size() < 2) return null
    
    def totalInstructions = 0
    def coveredInstructions = 0
    def totalBranches = 0
    def coveredBranches = 0
    def totalLines = 0
    def coveredLines = 0
    
    // CSV 헤더를 건너뛰고 데이터 행들을 처리
    lines[1..-1].each { line ->
        def parts = line.split(',')
        if (parts.size() >= 12) {
            totalInstructions += parts[3] as Integer
            coveredInstructions += parts[4] as Integer
            totalBranches += parts[5] as Integer
            coveredBranches += parts[6] as Integer
            totalLines += parts[7] as Integer
            coveredLines += parts[8] as Integer
        }
    }
    
    return [
        instructions: [total: totalInstructions, covered: coveredInstructions],
        branches: [total: totalBranches, covered: coveredBranches],
        lines: [total: totalLines, covered: coveredLines]
    ]
}

// 커버리지 요약 정보 출력 함수
def printCoverageSummary(coverageData) {
    if (!coverageData) {
        println "⚠️ 커버리지 데이터를 읽을 수 없습니다."
        return
    }
    
    def instructionCoverage = coverageData.instructions.total > 0 ? 
        (coverageData.instructions.covered / coverageData.instructions.total * 100) : 0
    def branchCoverage = coverageData.branches.total > 0 ? 
        (coverageData.branches.covered / coverageData.branches.total * 100) : 0
    def lineCoverage = coverageData.lines.total > 0 ? 
        (coverageData.lines.covered / coverageData.lines.total * 100) : 0
    
    println ""
    println "=" * 60
    println "📊 JUnit 테스트 코드 커버리지 결과"
    println "=" * 60
    printf "📋 라인 커버리지:        %d/%d (%.1f%%)\n", 
        coverageData.lines.covered, coverageData.lines.total, lineCoverage
    printf "🎯 명령어 커버리지:      %d/%d (%.1f%%)\n", 
        coverageData.instructions.covered, coverageData.instructions.total, instructionCoverage
    printf "🔀 분기 커버리지:        %d/%d (%.1f%%)\n", 
        coverageData.branches.covered, coverageData.branches.total, branchCoverage
    println "=" * 60
    
    // 커버리지 품질 평가
    def overallCoverage = lineCoverage
    if (overallCoverage >= 80) {
        println "✅ 우수한 코드 커버리지입니다! (80% 이상)"
    } else if (overallCoverage >= 60) {
        println "⚠️ 양호한 코드 커버리지입니다. (60-80%)"
    } else if (overallCoverage >= 40) {
        println "🔶 개선이 필요한 코드 커버리지입니다. (40-60%)"
    } else {
        println "🔴 코드 커버리지가 낮습니다. 추가 테스트가 필요합니다. (40% 미만)"
    }
    println ""
}

// JAR 파일 생성 설정
jar {
    manifest {
        attributes 'Main-Class': 'tetris.Tetris'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}


// ===== exe 빌드 관련 =====

// --- dist 정리: Delete 타입으로 깔끔하게 ---
tasks.register('cleanDist', Delete) {
    delete layout.projectDirectory.dir('dist')
}

// --- jpackage : app-image ---
tasks.register('jpackageExe', Exec) {
    dependsOn 'cleanDist', 'jar'
    group = 'distribution'
    description = 'Creates a native application image with icon'

    def jp = "${System.getProperty('java.home')}/bin/jpackage.exe"
    
    // 아이콘 파일 확인
    def iconFile = file("D:/SE/SE_Tetris_Team1/src/main/resources/Tetris.ico")
    def commandArgs = [
        '--input', 'build/libs',
        '--main-jar', jar.archiveFileName.get(),
        '--main-class', 'tetris.Tetris',
        '--name', 'Tetris Game',
        '--type', 'app-image',
        '--dest', 'dist',
        '--vendor', 'SE_Tetris_Team1',
        '--description', 'Tetris Game with Items and Difficulty Modes',
        '--app-version', '1.0.0'
    ]
    
    // 아이콘 파일이 존재하면 추가
    if (iconFile.exists()) {
        commandArgs.add('--icon')
        commandArgs.add(iconFile.absolutePath)
        println "Using icon file: ${iconFile.absolutePath}"
    } else {
        println "Warning: icon.ico not found. Building without icon."
    }
    
    commandLine([jp] + commandArgs)
}

// Checkstyle 설정 (비활성화)
checkstyle {
    toolVersion = '8.45.1'
    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")
    ignoreFailures = true
}

// Checkstyle 작업을 건너뛰도록 설정
tasks.withType(Checkstyle) {
    enabled = false
}

// SpotBugs 설정
spotbugs {
    ignoreFailures = true  // 빌드 실패를 방지하고 경고로만 처리
    reportLevel = 'medium'
    effort = 'default'
}

spotbugsMain {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/main/spotbugs.html")
        }
    }
}

spotbugsTest {
    reports {
        html {
            required = true
            outputLocation = file("$buildDir/reports/spotbugs/test/spotbugs.html")
        }
    }
}

// ===== 커버리지 관련 편의 태스크들 =====

// 테스트 + 커버리지 한 번에 실행
tasks.register('testWithCoverage') {
    group = 'verification'
    description = 'JUnit 테스트 실행 후 커버리지 리포트 생성 및 콘솔 출력'
    dependsOn test, jacocoTestReport
}

// 커버리지만 다시 생성 (테스트는 실행하지 않음)
tasks.register('coverageReport') {
    group = 'reporting'
    description = '기존 테스트 결과를 바탕으로 커버리지 리포트만 다시 생성'
    dependsOn jacocoTestReport
}

// 커버리지 검증 태스크 (최소 커버리지 기준 설정)
jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    
    violationRules {
        rule {
            limit {
                minimum = 0.60  // 최소 60% 라인 커버리지 요구
            }
        }
        
        rule {
            enabled = true
            element = 'CLASS'
            excludes = ['**.*Test*', '**.*Main*', '**.*Tetris*']
            
            limit {
                counter = 'LINE'
                value = 'COVEREDRATIO'
                minimum = 0.6  // 개별 클래스는 최소 60% 커버리지
            }
        }
    }
}
